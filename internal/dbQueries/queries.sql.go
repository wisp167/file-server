// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package dbQueries

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const countFiles = `-- name: CountFiles :one
SELECT COUNT(*) FROM files
`

func (q *Queries) CountFiles(ctx context.Context) (int64, error) {
	row := q.queryRow(ctx, q.countFilesStmt, countFiles)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countFilesByName = `-- name: CountFilesByName :one
SELECT COUNT(*) FROM files
WHERE file_name ILIKE '%' || $1 || '%'
`

func (q *Queries) CountFilesByName(ctx context.Context, dollar_1 sql.NullString) (int64, error) {
	row := q.queryRow(ctx, q.countFilesByNameStmt, countFilesByName, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createFile = `-- name: CreateFile :one
INSERT INTO files (id, file_name, file_data, create_time, update_time)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, create_time, update_time, file_data, file_name
`

type CreateFileParams struct {
	ID         uuid.UUID `json:"id"`
	FileName   string    `json:"file_name"`
	FileData   []byte    `json:"file_data"`
	CreateTime time.Time `json:"create_time"`
	UpdateTime time.Time `json:"update_time"`
}

func (q *Queries) CreateFile(ctx context.Context, arg CreateFileParams) (File, error) {
	row := q.queryRow(ctx, q.createFileStmt, createFile,
		arg.ID,
		arg.FileName,
		arg.FileData,
		arg.CreateTime,
		arg.UpdateTime,
	)
	var i File
	err := row.Scan(
		&i.ID,
		&i.CreateTime,
		&i.UpdateTime,
		&i.FileData,
		&i.FileName,
	)
	return i, err
}

const deleteFile = `-- name: DeleteFile :exec
DELETE FROM files
WHERE id = $1
`

func (q *Queries) DeleteFile(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteFileStmt, deleteFile, id)
	return err
}

const getFileByID = `-- name: GetFileByID :one
SELECT id, create_time, update_time, file_data, file_name FROM files
WHERE id = $1
`

func (q *Queries) GetFileByID(ctx context.Context, id uuid.UUID) (File, error) {
	row := q.queryRow(ctx, q.getFileByIDStmt, getFileByID, id)
	var i File
	err := row.Scan(
		&i.ID,
		&i.CreateTime,
		&i.UpdateTime,
		&i.FileData,
		&i.FileName,
	)
	return i, err
}

const getFileByName = `-- name: GetFileByName :many

SELECT id, create_time, update_time, file_data, file_name from files
WHERE file_name ILIKE '%' || $1 || '%'
`

// ./internal/sql
func (q *Queries) GetFileByName(ctx context.Context, dollar_1 sql.NullString) ([]File, error) {
	rows, err := q.query(ctx, q.getFileByNameStmt, getFileByName, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []File
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.CreateTime,
			&i.UpdateTime,
			&i.FileData,
			&i.FileName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFiles = `-- name: ListFiles :many
SELECT id, create_time, update_time, file_data, file_name FROM files
ORDER BY file_name
`

func (q *Queries) ListFiles(ctx context.Context) ([]File, error) {
	rows, err := q.query(ctx, q.listFilesStmt, listFiles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []File
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.CreateTime,
			&i.UpdateTime,
			&i.FileData,
			&i.FileName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchFiles = `-- name: SearchFiles :many
SELECT id, create_time, update_time, file_data, file_name FROM files
WHERE file_name ILIKE '%' || $1 || '%'
`

func (q *Queries) SearchFiles(ctx context.Context, dollar_1 sql.NullString) ([]File, error) {
	rows, err := q.query(ctx, q.searchFilesStmt, searchFiles, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []File
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.CreateTime,
			&i.UpdateTime,
			&i.FileData,
			&i.FileName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFile = `-- name: UpdateFile :one
UPDATE files
SET
    file_name = $2,
    file_data = $3,
    update_time = $4
WHERE id = $1
RETURNING id, create_time, update_time, file_data, file_name
`

type UpdateFileParams struct {
	ID         uuid.UUID `json:"id"`
	FileName   string    `json:"file_name"`
	FileData   []byte    `json:"file_data"`
	UpdateTime time.Time `json:"update_time"`
}

func (q *Queries) UpdateFile(ctx context.Context, arg UpdateFileParams) (File, error) {
	row := q.queryRow(ctx, q.updateFileStmt, updateFile,
		arg.ID,
		arg.FileName,
		arg.FileData,
		arg.UpdateTime,
	)
	var i File
	err := row.Scan(
		&i.ID,
		&i.CreateTime,
		&i.UpdateTime,
		&i.FileData,
		&i.FileName,
	)
	return i, err
}
